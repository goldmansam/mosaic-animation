<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Cloud Image</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: #999;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s;
    }
    #hint.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="hint">üñ±Ô∏è Scroll to zoom ‚Ä¢ WASD to move</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ============ CONFIGURATION ============
    const IMAGE_PATH = 'koi.jpg';
    const SAMPLE_STEP = 3;              // Particle density (2=dense, 3=balanced, 4=sparse)
    const DEPTH_RANGE = 4;              // How deep the particle cloud is (Z-axis spread when inside)
    const IMAGE_SCALE = 12;             // Size of the final image when viewed from far (larger = fills screen better)
    const PARTICLE_SIZE = 0.15;         // Base particle size (smaller for more spacing)

    // Camera starting position (center of the cloud)
    const START_POS = { x: 0, y: 0, z: 0 }; // Start at center of cloud

    // ============ SCENE SETUP ============
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      75,  // Wider FOV to see more of the image
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );
    camera.position.set(START_POS.x, START_POS.y, START_POS.z);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    console.log('Scene initialized');

    // ============ LOAD IMAGE & CREATE PARTICLES ============
    const img = new Image();
    let particles = null;

    img.onload = () => {
      console.log('Image loaded:', img.width, 'x', img.height);

      // Sample pixels from image
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, img.width, img.height);

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];

      // Create particles with random distribution
      for (let y = 0; y < img.height; y += SAMPLE_STEP) {
        for (let x = 0; x < img.width; x += SAMPLE_STEP) {
          const i = (y * img.width + x) * 4;
          const r = imageData.data[i] / 255;
          const g = imageData.data[i + 1] / 255;
          const b = imageData.data[i + 2] / 255;
          const a = imageData.data[i + 3] / 255;

          if (a < 0.1) continue; // Skip transparent

          // Image position (X, Y are image coordinates, Z=0 for flat)
          const imgX = (x / img.width - 0.5) * IMAGE_SCALE;
          const imgY = -(y / img.height - 0.5) * IMAGE_SCALE * (img.height / img.width);

          // Add random jitter to X and Y for even distribution
          const jitterX = (Math.random() - 0.5) * (IMAGE_SCALE / img.width) * SAMPLE_STEP;
          const jitterY = (Math.random() - 0.5) * (IMAGE_SCALE / img.height) * SAMPLE_STEP;

          const px = imgX + jitterX;
          const py = imgY + jitterY;

          // Random depth for 3D cloud effect
          const pz = (Math.random() - 0.5) * DEPTH_RANGE;

          positions.push(px, py, pz);
          colors.push(r * 1.2, g * 1.2, b * 1.2); // Slight brightness boost

          // Size based on brightness with variation
          const brightness = (r + g + b) / 3;
          const size = 0.05 + brightness * 0.05;
          sizes.push(size);
        }
      }

      console.log(`Created ${positions.length / 3} particles`);

      // Shuffle particles to avoid systematic ordering bias
      const particleCount = positions.length / 3;
      const indices = Array.from({ length: particleCount }, (_, i) => i);

      // Fisher-Yates shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      const shuffledPositions = new Float32Array(positions.length);
      const shuffledColors = new Float32Array(colors.length);
      const shuffledSizes = new Float32Array(sizes.length);

      for (let i = 0; i < particleCount; i++) {
        const srcIdx = indices[i];
        shuffledPositions[i * 3] = positions[srcIdx * 3];
        shuffledPositions[i * 3 + 1] = positions[srcIdx * 3 + 1];
        shuffledPositions[i * 3 + 2] = positions[srcIdx * 3 + 2];
        shuffledColors[i * 3] = colors[srcIdx * 3];
        shuffledColors[i * 3 + 1] = colors[srcIdx * 3 + 1];
        shuffledColors[i * 3 + 2] = colors[srcIdx * 3 + 2];
        shuffledSizes[i] = sizes[srcIdx];
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(shuffledPositions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(shuffledColors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(shuffledSizes, 1));

      // Material with custom size attribute
      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,  // Lower opacity for more spacious feel
        sizeAttenuation: true,
        blending: THREE.NormalBlending,
        depthWrite: false,
        depthTest: true  // Ensure particles render in correct depth order
      });

      // Store original Z positions for morphing
      const originalZ = new Float32Array(positions.length / 3);
      for (let i = 0; i < positions.length / 3; i++) {
        originalZ[i] = positions[i * 3 + 2];
      }
      geometry.userData.originalZ = originalZ;

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      console.log('Particles added to scene');

      // Show hint
      setTimeout(() => {
        document.getElementById('hint').classList.add('show');
      }, 500);

      // Start animation
      animate();
    };

    img.onerror = () => {
      console.error('Failed to load image');
      document.body.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">Failed to load koi.jpg</div>';
    };

    img.src = IMAGE_PATH;

    // ============ CONTROLS ============
    const moveSpeed = 0.1;
    const keys = {};

    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      // Move forward/backward on scroll
      const forward = new THREE.Vector3(0, 0, 1);
      forward.applyQuaternion(camera.quaternion);
      camera.position.addScaledVector(forward, e.deltaY * 0.01);
    }, { passive: false });

    // ============ ANIMATION LOOP ============
    function animate() {
      requestAnimationFrame(animate);

      // WASD movement
      if (keys['w']) camera.position.z += moveSpeed;
      if (keys['s']) camera.position.z -= moveSpeed;
      if (keys['a']) camera.position.x -= moveSpeed;
      if (keys['d']) camera.position.x += moveSpeed;
      if (keys['q']) camera.position.y += moveSpeed;
      if (keys['e']) camera.position.y -= moveSpeed;

      // Flatten particles as camera moves away for clearer image
      if (particles && particles.geometry.userData.originalZ) {
        const positions = particles.geometry.attributes.position.array;
        const originalZ = particles.geometry.userData.originalZ;

        // Calculate distance from camera to center of cloud
        const distance = camera.position.length();

        // Flatten factor: 0 at center (distance=0), 1 at distance=2.5
        // Image fully resolves very quickly at close distance
        const flattenFactor = Math.max(0, Math.min(1, distance / 2.5));

        // Morph Z positions
        for (let i = 0; i < originalZ.length; i++) {
          // Compress depth as we zoom out
          positions[i * 3 + 2] = originalZ[i] * (1 - flattenFactor * 0.85);
        }

        particles.geometry.attributes.position.needsUpdate = true;

        // Adjust material based on distance
        const material = particles.material;

        // Always use normal blending for true colors
        material.blending = THREE.NormalBlending;

        // Keep opacity constant for consistent brightness
        material.opacity = 0.6;

        // Keep particles larger to avoid gaps
        material.size = PARTICLE_SIZE * (1 - flattenFactor * 0.1);
      }

      renderer.render(scene, camera);
    }

    // ============ RESIZE ============
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
