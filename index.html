<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Cloud Image</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ============ CONFIGURATION ============
    const IMAGE_PATH = 'samuel-arkwright.jpg';

    // Particle density - every pixel for maximum clarity
    const SAMPLE_STEP = 1;

    // Depth range when in cloud mode (scattered in Z)
    const CLOUD_DEPTH = 60;  // 2.5x original (was 24)

    // Starting position - inside the cloud
    const START_CAMERA_Z = 0;

    // Distance where image is fully resolved and clear
    const IMAGE_VIEW_DISTANCE = 15;

    // Particle appearance - balanced for sharpness and coverage
    const PARTICLE_SIZE = 0.008;

    // ============ SCENE SETUP ============
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    // Camera will be controlled by keyframe animation
    camera.position.set(-60, 0, 0);
    camera.rotation.set(0, -Math.PI / 2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0x000000, 1); // Black background
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ============ LOAD IMAGE ============
    const img = new Image();
    img.crossOrigin = "anonymous";  // Allow CORS for local files
    let points = null;
    let originalCloudZ = null;

    img.onload = () => {
      console.log(`Image loaded: ${img.width}x${img.height}`);

      // Sample image pixels
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, img.width, img.height);

      const positions = [];
      const colors = [];
      const cloudZPositions = [];

      // Calculate scale to fit nicely in view
      const aspect = img.height / img.width;
      const imageWidth = 8;
      const imageHeight = imageWidth * aspect;

      // Sample pixels
      let particleCount = 0;
      for (let y = 0; y < img.height; y += SAMPLE_STEP) {
        for (let x = 0; x < img.width; x += SAMPLE_STEP) {
          const i = (y * img.width + x) * 4;
          const r = imageData.data[i] / 255;
          const g = imageData.data[i + 1] / 255;
          const b = imageData.data[i + 2] / 255;
          const a = imageData.data[i + 3] / 255;

          if (a < 0.1) continue; // Skip transparent

          // Image position (X, Y for image, Z will morph)
          const px = (x / img.width - 0.5) * imageWidth;
          const py = -(y / img.height - 0.5) * imageHeight;

          // Store cloud Z (random depth) separately
          const cloudZ = (Math.random() - 0.5) * CLOUD_DEPTH;

          positions.push(px, py, 0); // Start flat at Z=0
          colors.push(r, g, b);
          cloudZPositions.push(cloudZ);
          particleCount++;
        }
      }

      console.log(`Created ${particleCount} particles`);

      // Shuffle particles to eliminate systematic ordering bias
      const indices = Array.from({ length: particleCount }, (_, i) => i);

      // Fisher-Yates shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      const shuffledPositions = new Float32Array(particleCount * 3);
      const shuffledColors = new Float32Array(particleCount * 3);
      const shuffledCloudZ = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const srcIdx = indices[i];
        shuffledPositions[i * 3] = positions[srcIdx * 3];
        shuffledPositions[i * 3 + 1] = positions[srcIdx * 3 + 1];
        shuffledPositions[i * 3 + 2] = positions[srcIdx * 3 + 2];
        shuffledColors[i * 3] = colors[srcIdx * 3];
        shuffledColors[i * 3 + 1] = colors[srcIdx * 3 + 1];
        shuffledColors[i * 3 + 2] = colors[srcIdx * 3 + 2];
        shuffledCloudZ[i] = cloudZPositions[srcIdx];
      }

      // Create geometry with shuffled data
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(shuffledPositions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(shuffledColors, 3));

      // Store cloud Z positions for morphing
      originalCloudZ = shuffledCloudZ;

      // Material - square particles for perfect grid coverage
      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        transparent: true,
        opacity: 1.0,  // Full opacity to eliminate grid
        sizeAttenuation: true,
        depthWrite: false
        // No map = square particles (eliminates grid lines)
      });

      points = new THREE.Points(geometry, material);
      scene.add(points);

      animate();
    };

    img.onerror = () => {
      console.error('Failed to load image');
      document.body.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">Failed to load image</div>';
    };

    img.src = IMAGE_PATH;

    // ============ CINEMATIC ANIMATION ============
    // Define keyframes with exact positions and rotations
    const keyframes = [
      { x: -60, y: 0, z: 0, rotX: 0, rotY: -Math.PI / 2, rotZ: 0, duration: 8000 },  // Keyframe 1: Side view
      { x: 0, y: 0, z: 0, rotX: 0, rotY: 0, rotZ: 0, duration: 6000 },              // Keyframe 2: Center, face forward
      { x: 0, y: 0, z: 14.65, rotX: 0, rotY: 0, rotZ: 0, duration: 6000 },          // Keyframe 3: Zoom out to reveal
      { x: 0, y: 0, z: 0, rotX: 0, rotY: 0, rotZ: 0, duration: 6000 },              // Keyframe 4: Back to center
      { x: -60, y: 0, z: 0, rotX: 0, rotY: -Math.PI / 2, rotZ: 0, duration: 8000 }  // Keyframe 5: Back to side view
    ];

    let animationStartTime = Date.now();
    const TOTAL_LOOP_TIME = keyframes.reduce((sum, kf) => sum + kf.duration, 0);

    // Easing function for smooth transitions
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // ============ ANIMATION ============
    function animate() {
      requestAnimationFrame(animate);

      if (!points || !originalCloudZ) return;

      // Calculate current time in loop
      const elapsed = (Date.now() - animationStartTime) % TOTAL_LOOP_TIME;

      // Find current keyframe
      let accumulatedTime = 0;
      let currentKeyframeIndex = 0;
      let localTime = elapsed;

      for (let i = 0; i < keyframes.length; i++) {
        if (elapsed < accumulatedTime + keyframes[i].duration) {
          currentKeyframeIndex = i;
          localTime = elapsed - accumulatedTime;
          break;
        }
        accumulatedTime += keyframes[i].duration;
      }

      // Get current and next keyframe
      const currentKF = keyframes[currentKeyframeIndex];
      const nextKF = keyframes[(currentKeyframeIndex + 1) % keyframes.length];

      // Calculate interpolation factor
      let t = localTime / currentKF.duration;
      t = easeInOutCubic(t);  // Apply easing for smooth transition

      // Interpolate camera position
      camera.position.x = currentKF.x + (nextKF.x - currentKF.x) * t;
      camera.position.y = currentKF.y + (nextKF.y - currentKF.y) * t;
      camera.position.z = currentKF.z + (nextKF.z - currentKF.z) * t;

      // Interpolate camera rotation (slowly transition angle while moving)
      camera.rotation.x = currentKF.rotX + (nextKF.rotX - currentKF.rotX) * t;
      camera.rotation.y = currentKF.rotY + (nextKF.rotY - currentKF.rotY) * t;
      camera.rotation.z = currentKF.rotZ + (nextKF.rotZ - currentKF.rotZ) * t;

      // Calculate morph factor
      // At z=0 (inside): morphFactor = 0 (full cloud)
      // At z=IMAGE_VIEW_DISTANCE: morphFactor = 1 (flat image)
      const distance = camera.position.z;
      let morphFactor = distance / IMAGE_VIEW_DISTANCE;
      morphFactor = Math.max(0, Math.min(1, morphFactor));

      // Apply easing for smooth transition
      morphFactor = morphFactor * morphFactor * (3 - 2 * morphFactor); // Smoothstep

      // Morph particle Z positions
      const positions = points.geometry.attributes.position.array;
      for (let i = 0; i < originalCloudZ.length; i++) {
        // Interpolate between cloud depth and flat (z=0)
        // morphFactor=0: use cloudZ (scattered)
        // morphFactor=1: use 0 (perfectly flat image)
        positions[i * 3 + 2] = originalCloudZ[i] * (1 - morphFactor);
      }
      points.geometry.attributes.position.needsUpdate = true;

      // Scale up the entire particle system as it resolves to fill entire window
      // morphFactor=0 (cloud): scale = 1.0
      // morphFactor=1 (image): scale = 6.0 (fills entire screen)
      const scale = 1.0 + (morphFactor * 5.0);
      points.scale.set(scale, scale, scale);

      // Adjust particle size and opacity - optimized for clarity
      const material = points.material;

      // Minimal size multiplier for maximum sharpness
      material.size = PARTICLE_SIZE * scale * 2.0;

      // Full opacity to eliminate grid visibility
      material.opacity = 1.0;

      renderer.render(scene, camera);
    }

    // ============ RESIZE ============
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
