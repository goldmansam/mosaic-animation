<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Image</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: #666;
      pointer-events: none;
    }
    #hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #666;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s;
    }
    #hint.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="canvas"></div>
  <div id="loading">Loading...</div>
  <div id="hint">üñ±Ô∏è Scroll to zoom ‚Ä¢ Close = particles ‚Ä¢ Far = image</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    try {
      const THREE = await import('three');
      window.THREE = THREE;
    } catch (err) {
      document.getElementById('loading').innerHTML = 'Error loading Three.js. Check internet connection.';
      console.error('Failed to load Three.js:', err);
      throw err;
    }

    const THREE = window.THREE;

    // ============ CONFIGURATION ============
    const IMAGE_PATH = 'koi.jpg';          // Your image
    const SAMPLE_STEP = 4;                  // Downsample: 2=dense, 3=balanced, 4=sparse
    const POINT_SIZE = 12.0;                // Base point size in pixels (increased for visibility)
    const PARTICLE_RADIUS = 5.0;            // Sphere radius for particle cloud

    // Camera distances
    const NEAR_DISTANCE = 3;                // Inside cloud (particles scattered)
    const FAR_DISTANCE = 12;                // Far away (image resolved)
    const START_DISTANCE = 7;               // Start mid-way so you can see something immediately

    // Animation
    const DRIFT_STRENGTH = 0.02;            // Particle drift in cloud mode

    // ============ SCENE SETUP ============
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a); // Slightly gray to see particles better

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.z = START_DISTANCE;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas').appendChild(renderer.domElement);

    console.log('Renderer created:', renderer);
    console.log('Canvas element:', renderer.domElement);
    console.log('WebGL context:', renderer.getContext());

    // ============ SHADERS ============
    const vertexShader = `
      uniform float uProgress;
      uniform float uSize;
      uniform float uTime;

      attribute vec3 aImagePos;    // Image position
      attribute vec3 aCloudPos;    // Cloud position
      attribute vec3 aColor;       // Pixel color
      attribute float aBrightness; // For size variation

      varying vec3 vColor;

      // Simple noise
      float noise(vec3 p) {
        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
      }

      void main() {
        vColor = aColor;

        // Morph between cloud and image
        vec3 pos = mix(aCloudPos, aImagePos, uProgress);

        // Add drift that fades as image resolves
        float driftAmount = (1.0 - uProgress) * ${DRIFT_STRENGTH};
        vec3 drift = vec3(
          noise(aCloudPos + uTime * 0.3),
          noise(aCloudPos.yzx + uTime * 0.3 + 10.0),
          noise(aCloudPos.zxy + uTime * 0.3 + 20.0)
        ) * 2.0 - 1.0;
        pos += drift * driftAmount;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // Brightness-weighted size, scaled by distance
        float sizeMult = 1.0 + aBrightness * 0.5;
        gl_PointSize = uSize * sizeMult * (300.0 / -mvPosition.z);
      }
    `;

    const fragmentShader = `
      varying vec3 vColor;

      void main() {
        // Circular sprite
        vec2 center = gl_PointCoord - vec2(0.5);
        float dist = length(center);

        if (dist > 0.5) discard;

        // Soft edges
        float alpha = smoothstep(0.5, 0.25, dist);

        // Boost brightness to make particles more visible
        vec3 brightColor = vColor * 1.5;
        gl_FragColor = vec4(brightColor, alpha);
      }
    `;

    // ============ IMAGE LOADING ============
    let pointsObject = null;
    let material = null;

    async function loadImage() {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = IMAGE_PATH;
      });
    }

    function sampleImageData(img) {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      return ctx.getImageData(0, 0, img.width, img.height);
    }

    function createParticleSystem(img) {
      const imageData = sampleImageData(img);
      const { data, width, height } = imageData;
      const particles = [];

      // Sample pixels
      for (let y = 0; y < height; y += SAMPLE_STEP) {
        for (let x = 0; x < width; x += SAMPLE_STEP) {
          const i = (y * width + x) * 4;
          const r = data[i] / 255;
          const g = data[i + 1] / 255;
          const b = data[i + 2] / 255;
          const a = data[i + 3] / 255;

          // Skip transparent pixels
          if (a < 0.1) continue;

          // Image position (flat grid, centered)
          const imgX = (x / width - 0.5) * 6;
          const imgY = -(y / height - 0.5) * 6 * (height / width);
          const imgZ = 0;

          // Cloud position (uniform sphere)
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);
          const radius = Math.cbrt(Math.random()) * PARTICLE_RADIUS;
          const cloudX = radius * Math.sin(phi) * Math.cos(theta);
          const cloudY = radius * Math.sin(phi) * Math.sin(theta);
          const cloudZ = radius * Math.cos(phi);

          particles.push({
            imagePos: [imgX, imgY, imgZ],
            cloudPos: [cloudX, cloudY, cloudZ],
            color: [r, g, b],
            brightness: (r + g + b) / 3
          });
        }
      }

      console.log(`Created ${particles.length} particles`);

      // Build geometry
      const geometry = new THREE.BufferGeometry();
      const count = particles.length;

      const imagePositions = new Float32Array(count * 3);
      const cloudPositions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const brightnesses = new Float32Array(count);

      particles.forEach((p, i) => {
        imagePositions[i * 3] = p.imagePos[0];
        imagePositions[i * 3 + 1] = p.imagePos[1];
        imagePositions[i * 3 + 2] = p.imagePos[2];

        cloudPositions[i * 3] = p.cloudPos[0];
        cloudPositions[i * 3 + 1] = p.cloudPos[1];
        cloudPositions[i * 3 + 2] = p.cloudPos[2];

        colors[i * 3] = p.color[0];
        colors[i * 3 + 1] = p.color[1];
        colors[i * 3 + 2] = p.color[2];

        brightnesses[i] = p.brightness;
      });

      geometry.setAttribute('aImagePos', new THREE.BufferAttribute(imagePositions, 3));
      geometry.setAttribute('aCloudPos', new THREE.BufferAttribute(cloudPositions, 3));
      geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('aBrightness', new THREE.BufferAttribute(brightnesses, 1));

      // Create material
      material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uProgress: { value: 0 },
          uSize: { value: POINT_SIZE },
          uTime: { value: 0 }
        },
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      pointsObject = new THREE.Points(geometry, material);
      pointsObject.frustumCulled = false;
      scene.add(pointsObject);
    }

    // ============ INTERACTION ============
    let targetDistance = START_DISTANCE;

    window.addEventListener('wheel', (e) => {
      e.preventDefault();

      const delta = e.deltaY * 0.01;
      targetDistance += delta;
      targetDistance = Math.max(NEAR_DISTANCE, Math.min(FAR_DISTANCE, targetDistance));
    }, { passive: false });

    // ============ ANIMATION ============
    const clock = new THREE.Clock();
    let frameCount = 0;

    function animate() {
      requestAnimationFrame(animate);

      if (!material) return;

      const time = clock.getElapsedTime();

      // Smooth camera movement
      camera.position.z += (targetDistance - camera.position.z) * 0.05;

      // Map distance to progress (near=0/cloud, far=1/image)
      const progress = (camera.position.z - NEAR_DISTANCE) / (FAR_DISTANCE - NEAR_DISTANCE);
      const easedProgress = progress * progress * (3 - 2 * progress); // Smoothstep

      material.uniforms.uProgress.value = Math.max(0, Math.min(1, easedProgress));
      material.uniforms.uTime.value = time;

      renderer.render(scene, camera);

      // Debug log first few frames
      if (frameCount < 3) {
        console.log(`Frame ${frameCount}: camera.z=${camera.position.z.toFixed(2)}, progress=${easedProgress.toFixed(2)}, particles in scene=${scene.children.length}`);
        frameCount++;
      }
    }

    // ============ RESIZE ============
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ============ START ============
    console.log('Starting particle system...');
    console.log('THREE loaded:', typeof THREE);

    loadImage().then(img => {
      console.log('Image loaded:', img.width, 'x', img.height);
      createParticleSystem(img);
      console.log('Particle system created');
      document.getElementById('loading').style.display = 'none';

      // Show hint after 1 second
      setTimeout(() => {
        document.getElementById('hint').classList.add('show');
      }, 1000);

      animate();
    }).catch(err => {
      console.error('Failed to load image:', err);
      document.getElementById('loading').innerHTML = 'Error: ' + err.message;
    });
  </script>
</body>
</html>
