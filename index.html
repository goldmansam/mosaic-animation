<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Cloud Image</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 13px;
      color: #777;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s;
    }
    #hint.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="hint">Scroll to zoom • Inside = particle cloud • Outside = clear image</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ============ CONFIGURATION ============
    const IMAGE_PATH = 'koi.jpg';

    // Particle density - sample almost every pixel for maximum clarity
    const SAMPLE_STEP = 2;

    // Depth range when in cloud mode (scattered in Z)
    const CLOUD_DEPTH = 24;  // 4x the original depth (was 6)

    // Starting position - inside the cloud
    const START_CAMERA_Z = 0;

    // Distance where image is fully resolved and clear
    const IMAGE_VIEW_DISTANCE = 15;

    // Particle appearance
    const PARTICLE_SIZE = 0.06;

    // ============ SCENE SETUP ============
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.z = START_CAMERA_Z;
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ============ LOAD IMAGE ============
    const img = new Image();
    let points = null;
    let originalCloudZ = null;

    img.onload = () => {
      console.log(`Image loaded: ${img.width}x${img.height}`);

      // Sample image pixels
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, img.width, img.height);

      const positions = [];
      const colors = [];
      const cloudZPositions = [];

      // Calculate scale to fit nicely in view
      const aspect = img.height / img.width;
      const imageWidth = 8;
      const imageHeight = imageWidth * aspect;

      // Sample pixels densely
      let particleCount = 0;
      for (let y = 0; y < img.height; y += SAMPLE_STEP) {
        for (let x = 0; x < img.width; x += SAMPLE_STEP) {
          const i = (y * img.width + x) * 4;
          const r = imageData.data[i] / 255;
          const g = imageData.data[i + 1] / 255;
          const b = imageData.data[i + 2] / 255;
          const a = imageData.data[i + 3] / 255;

          if (a < 0.1) continue; // Skip transparent

          // Image position (X, Y for image, Z will morph)
          const px = (x / img.width - 0.5) * imageWidth;
          const py = -(y / img.height - 0.5) * imageHeight;

          // Store cloud Z (random depth) separately
          const cloudZ = (Math.random() - 0.5) * CLOUD_DEPTH;

          positions.push(px, py, 0); // Start flat at Z=0
          colors.push(r, g, b);
          cloudZPositions.push(cloudZ);
          particleCount++;
        }
      }

      console.log(`Created ${particleCount} particles`);

      // Create geometry
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // Store cloud Z positions for morphing
      originalCloudZ = new Float32Array(cloudZPositions);

      // Material
      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
        depthWrite: false
      });

      points = new THREE.Points(geometry, material);
      scene.add(points);

      // Show hint
      setTimeout(() => {
        document.getElementById('hint').classList.add('show');
      }, 500);

      animate();
    };

    img.onerror = () => {
      console.error('Failed to load image');
      document.body.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">Failed to load koi.jpg</div>';
    };

    img.src = IMAGE_PATH;

    // ============ INTERACTION ============
    let targetCameraZ = START_CAMERA_Z;

    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      targetCameraZ += e.deltaY * 0.01;
      // No limits - move freely
    }, { passive: false });

    // WASD controls
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    // ============ ANIMATION ============
    function animate() {
      requestAnimationFrame(animate);

      if (!points || !originalCloudZ) return;

      // Smooth camera movement
      camera.position.z += (targetCameraZ - camera.position.z) * 0.08;

      // WASD movement - completely unrestricted
      const moveSpeed = 0.15;
      if (keys['w']) {
        camera.position.z += moveSpeed;
        targetCameraZ = camera.position.z;
      }
      if (keys['s']) {
        camera.position.z -= moveSpeed;
        targetCameraZ = camera.position.z;
      }
      if (keys['a']) camera.position.x -= moveSpeed;
      if (keys['d']) camera.position.x += moveSpeed;

      // Calculate morph factor
      // At z=0 (inside): morphFactor = 0 (full cloud)
      // At z=IMAGE_VIEW_DISTANCE: morphFactor = 1 (flat image)
      const distance = camera.position.z;
      let morphFactor = distance / IMAGE_VIEW_DISTANCE;
      morphFactor = Math.max(0, Math.min(1, morphFactor));

      // Apply easing for smooth transition
      morphFactor = morphFactor * morphFactor * (3 - 2 * morphFactor); // Smoothstep

      // Morph particle Z positions
      const positions = points.geometry.attributes.position.array;
      for (let i = 0; i < originalCloudZ.length; i++) {
        // Interpolate between cloud depth and flat (z=0)
        // morphFactor=0: use cloudZ (scattered)
        // morphFactor=1: use 0 (perfectly flat image)
        positions[i * 3 + 2] = originalCloudZ[i] * (1 - morphFactor);
      }
      points.geometry.attributes.position.needsUpdate = true;

      // Scale up the entire particle system as it resolves to fill entire window
      // morphFactor=0 (cloud): scale = 1.0
      // morphFactor=1 (image): scale = 2.5 (fills entire screen)
      const scale = 1.0 + (morphFactor * 1.5);
      points.scale.set(scale, scale, scale);

      // Adjust particle size and opacity to prevent grid artifacts
      const material = points.material;

      // Make particles larger as we scale up to fill gaps
      material.size = PARTICLE_SIZE * scale * 1.2;

      // Keep opacity high to prevent darkening
      material.opacity = 0.85;

      renderer.render(scene, camera);
    }

    // ============ RESIZE ============
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
