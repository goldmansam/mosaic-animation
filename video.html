<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Particle Cloud</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 13px;
      color: #777;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s;
    }
    #hint.show {
      opacity: 1;
    }
    #videoSource {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
    }
    #videoFile {
      display: none;
    }
    #chooseVideo {
      background: #fff;
      color: #000;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #chooseVideo:hover {
      background: #eee;
    }
    #videoContainer {
      display: none;
    }
  </style>
</head>
<body>
  <div id="videoSource">
    <button id="chooseVideo">Choose Video File</button>
    <input type="file" id="videoFile" accept="video/*">
  </div>

  <div id="hint">Scroll to zoom • Inside = particle cloud • Outside = clear video</div>

  <div id="videoContainer">
    <video id="videoElement" crossorigin="anonymous" loop muted playsinline></video>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ============ CONFIGURATION ============
    // Particle density - lower for video performance
    const SAMPLE_STEP = 4;

    // Depth range when in cloud mode
    const CLOUD_DEPTH = 6;

    // Starting position - inside the cloud
    const START_CAMERA_Z = 0;

    // Distance where video is fully resolved and clear
    const IMAGE_VIEW_DISTANCE = 8;

    // Particle appearance
    const PARTICLE_SIZE = 0.08;

    // Video resolution (lower for better performance)
    const VIDEO_WIDTH = 320;
    const VIDEO_HEIGHT = 240;

    // ============ SCENE SETUP ============
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.z = START_CAMERA_Z;
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ============ VIDEO SETUP ============
    const video = document.getElementById('videoElement');
    const videoFileInput = document.getElementById('videoFile');
    const chooseVideoBtn = document.getElementById('chooseVideo');

    let points = null;
    let originalCloudZ = null;
    let videoCanvas = null;
    let videoCtx = null;
    let particlePositions = null; // Store X,Y positions
    let videoLoaded = false;

    chooseVideoBtn.onclick = () => videoFileInput.click();

    videoFileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        video.src = url;
        video.load();
      }
    };

    video.onloadedmetadata = () => {
      console.log(`Video loaded: ${video.videoWidth}x${video.videoHeight}`);

      // Create offscreen canvas for video sampling
      videoCanvas = document.createElement('canvas');
      videoCanvas.width = VIDEO_WIDTH;
      videoCanvas.height = VIDEO_HEIGHT;
      videoCtx = videoCanvas.getContext('2d', { willReadFrequently: true });

      // Calculate particle grid
      const aspect = VIDEO_HEIGHT / VIDEO_WIDTH;
      const imageWidth = 8;
      const imageHeight = imageWidth * aspect;

      particlePositions = [];
      const cloudZPositions = [];
      const initialColors = [];

      // Create particle grid
      for (let y = 0; y < VIDEO_HEIGHT; y += SAMPLE_STEP) {
        for (let x = 0; x < VIDEO_WIDTH; x += SAMPLE_STEP) {
          const px = (x / VIDEO_WIDTH - 0.5) * imageWidth;
          const py = -(y / VIDEO_HEIGHT - 0.5) * imageHeight;
          const cloudZ = (Math.random() - 0.5) * CLOUD_DEPTH;

          particlePositions.push({ x: px, y: py, imgX: x, imgY: y });
          cloudZPositions.push(cloudZ);
          initialColors.push(0, 0, 0); // Will be updated from video
        }
      }

      console.log(`Created ${particlePositions.length} particles`);

      // Create geometry
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particlePositions.length * 3);

      for (let i = 0; i < particlePositions.length; i++) {
        positions[i * 3] = particlePositions[i].x;
        positions[i * 3 + 1] = particlePositions[i].y;
        positions[i * 3 + 2] = 0;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(initialColors, 3));

      originalCloudZ = new Float32Array(cloudZPositions);

      // Material
      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
        depthWrite: false
      });

      points = new THREE.Points(geometry, material);
      scene.add(points);

      // Hide video source UI
      document.getElementById('videoSource').style.display = 'none';

      // Show hint
      setTimeout(() => {
        document.getElementById('hint').classList.add('show');
      }, 500);

      // Start video playback
      video.play();
      videoLoaded = true;

      animate();
    };

    // ============ INTERACTION ============
    let targetCameraZ = START_CAMERA_Z;

    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      targetCameraZ += e.deltaY * 0.01;
    }, { passive: false });

    // WASD controls
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    // ============ ANIMATION ============
    function animate() {
      requestAnimationFrame(animate);

      if (!points || !originalCloudZ || !videoLoaded) return;

      // Update colors from video frame
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        videoCtx.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
        const imageData = videoCtx.getImageData(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

        const colors = points.geometry.attributes.color.array;
        for (let i = 0; i < particlePositions.length; i++) {
          const x = particlePositions[i].imgX;
          const y = particlePositions[i].imgY;
          const idx = (y * VIDEO_WIDTH + x) * 4;

          colors[i * 3] = imageData.data[idx] / 255;
          colors[i * 3 + 1] = imageData.data[idx + 1] / 255;
          colors[i * 3 + 2] = imageData.data[idx + 2] / 255;
        }
        points.geometry.attributes.color.needsUpdate = true;
      }

      // Smooth camera movement
      camera.position.z += (targetCameraZ - camera.position.z) * 0.08;

      // WASD movement
      const moveSpeed = 0.15;
      if (keys['w']) {
        camera.position.z += moveSpeed;
        targetCameraZ = camera.position.z;
      }
      if (keys['s']) {
        camera.position.z -= moveSpeed;
        targetCameraZ = camera.position.z;
      }
      if (keys['a']) camera.position.x -= moveSpeed;
      if (keys['d']) camera.position.x += moveSpeed;

      // Calculate morph factor
      const distance = camera.position.z;
      let morphFactor = distance / IMAGE_VIEW_DISTANCE;
      morphFactor = Math.max(0, Math.min(1, morphFactor));
      morphFactor = morphFactor * morphFactor * (3 - 2 * morphFactor); // Smoothstep

      // Morph particle Z positions
      const positions = points.geometry.attributes.position.array;
      for (let i = 0; i < originalCloudZ.length; i++) {
        positions[i * 3 + 2] = originalCloudZ[i] * (1 - morphFactor);
      }
      points.geometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }

    // ============ RESIZE ============
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
