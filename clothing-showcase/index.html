<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clothing Showcase</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 8); // Eye level - Y at 0 instead of 2
    camera.lookAt(0, 0, 0); // Look at center of circle

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting - Enhanced for better visibility and color
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
    scene.add(ambientLight);

    // Hemisphere light for natural color rendering
    const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
    scene.add(hemisphereLight);

    // Main key light from front-top
    const keyLight = new THREE.DirectionalLight(0xffffff, 2.5);
    keyLight.position.set(0, 10, 10);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    scene.add(keyLight);

    // Fill light from left
    const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
    fillLight.position.set(-10, 5, 5);
    scene.add(fillLight);

    // Rim light from right
    const rimLight = new THREE.DirectionalLight(0xffffff, 1.5);
    rimLight.position.set(10, 5, -5);
    scene.add(rimLight);

    // Back light for depth
    const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
    backLight.position.set(0, 3, -10);
    scene.add(backLight);

    // Bottom light to reduce harsh shadows
    const bottomLight = new THREE.DirectionalLight(0xffffff, 0.8);
    bottomLight.position.set(0, -10, 0);
    scene.add(bottomLight);

    // Add some colored accent lights
    const accentLight1 = new THREE.PointLight(0x4488ff, 0.5, 20);
    accentLight1.position.set(-8, 2, 0);
    scene.add(accentLight1);

    const accentLight2 = new THREE.PointLight(0xff8844, 0.5, 20);
    accentLight2.position.set(8, 2, 0);
    scene.add(accentLight2);

    // OrbitControls - disabled auto-rotate
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 3;
    controls.maxDistance = 15;
    controls.autoRotate = false;
    controls.enabled = false; // Disable controls entirely

    // Load models
    const loader = new GLTFLoader();
    const models = [];
    const modelFiles = [
      'Love (Final).gltf',
      'Pink Floyd (Final).gltf',
      'Purple Crown (Final).gltf',
      'Skyline Final.gltf',
      'Yellow Brick (final).gltf'
    ];

    let loadedCount = 0;

    modelFiles.forEach((file, index) => {
      loader.load(
        file,
        (gltf) => {
          const model = gltf.scene;

          // Stop any built-in animations
          if (gltf.animations && gltf.animations.length > 0) {
            console.log(`${file} has ${gltf.animations.length} animations (not playing)`);
          }

          // Center and scale model to uniform height
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          // Scale based on HEIGHT only (Y axis) to ensure all models same height
          const targetHeight = 2; // Target height for all models
          let scale = targetHeight / size.y;

          // Make Pink Floyd 5% bigger
          if (file === 'Pink Floyd (Final).gltf') {
            scale *= 1.05;
          }

          model.scale.setScalar(scale);

          // Center the model at origin
          model.position.x = -center.x * scale;
          model.position.y = -center.y * scale;
          model.position.z = -center.z * scale;

          // Create a container/group for this model
          const container = new THREE.Group();
          container.add(model);

          // Position the CONTAINER, not the model
          const spacing = 3;
          const offset = -(modelFiles.length - 1) * spacing / 2;
          container.position.set(offset + index * spacing, 0, 0);

          // Enable shadows
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          scene.add(container);
          models.push(container);

          loadedCount++;
          console.log(`Loaded ${loadedCount}/${modelFiles.length} models`);
        },
        (progress) => {
          console.log(`Loading ${file}: ${(progress.loaded / progress.total * 100).toFixed(0)}%`);
        },
        (error) => {
          console.error(`Error loading ${file}:`, error);
        }
      );
    });

    // Animation
    let time = 0;
    const circleRadius = 5; // Radius of circular path
    const circleSpeed = 0.005; // Speed of circular motion

    function animate() {
      requestAnimationFrame(animate);

      time += circleSpeed;

      // Move models in circular path AND rotate on their Y axis
      models.forEach((model, index) => {
        // Calculate angle for this model's position on the circle
        const angleOffset = (index / models.length) * Math.PI * 2; // Evenly space models
        const angle = time + angleOffset;

        // Position on circular path
        model.position.x = Math.cos(angle) * circleRadius;
        model.position.z = Math.sin(angle) * circleRadius;

        // Rotate model on its own Y axis
        model.rotation.y += 0.01;
      });

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
